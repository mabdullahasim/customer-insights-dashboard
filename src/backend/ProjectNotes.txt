1. main.py

Entry point for your FastAPI app.

Responsibilities:

Initialize FastAPI instance.

Include/register all API routers (auth, users, customers, analytics).

Add middleware if needed (CORS, logging, etc.).

Run app (development or production server).

#################################################################################################


2. core/ – foundational utilities

a. config.py

Store app-wide settings:

Secret keys for JWT

Database URLs

Token expiration times

Any environment-dependent variables

b. database.py

Create and manage the database connection.

Provide session factory for routes to access DB.

Initialize ORM base models.

c. security.py

Handle all security-related operations:

Password hashing and verification

JWT token creation and validation

Optional helpers: role/permission checks, token refresh logic


#################################################################################################

3. models/ – database tables

Define your database structure using ORM (e.g., SQLAlchemy).

Files:

user.py → DB fields for users (username, email, password hash, roles, etc.)

customer.py → DB fields for customers (name, email, review, satisfaction score, timestamps)

Optionally other models → e.g., analytics.py for precomputed metrics if needed

Responsibility: Only define how data is stored, not how it’s sent to the frontend.


#################################################################################################


4. schemas/ – validation and serialization

Define Pydantic models for input/output data in API.

Files:

user.py → UserCreate, UserRead, UserUpdate

customer.py → CustomerCreate, CustomerRead

Optionally analytics.py → AnalyticsRead for sending aggregated data to frontend

Responsibility: Validate incoming data and control outgoing data shape.



################################################################################################


5. api/ – API routes

Files:

auth.py → Authentication routes

Signup

Login

Token refresh (optional)

Password reset/change

users.py → User management routes

Get user profile

Update profile

List users (admin)

customers.py → Customer CRUD routes

Add customers (via CSV or form)

Get customer list

Update customer info

Delete customer (optional)

analytics.py → Data aggregation routes

Generate averages, trends, charts data

Filtered data for frontend visualization

Responsibility: Expose endpoints for frontend to interact with your backend.


################################################################################################


1. services/ – business logic

Purpose: Handle complex operations that don’t belong directly in a route or model.

Examples for your dashboard:

UserService → encapsulates things like creating a user, updating password, checking roles.

CustomerService → parsing CSV, storing multiple customer records, computing derived fields.

AnalyticsService → aggregate data for charts, calculate averages, trends, satisfaction metrics.

Key idea:

Routes in api/ just call these service functions.

Keeps endpoints thin and focused on request/response.


################################################################################################


2. utils/ – helper functions

Purpose: Small, reusable helpers that don’t fit in services or core.

Examples:

File handling: save/upload CSVs, validate file type

Data formatting: dates, numbers

Miscellaneous helpers: generate random IDs, parse strings

Difference from services/:

services/ = business logic (core app functionality)

utils/ = generic helpers that can be used anywh




models is to represent how data is stored in the database
    - user for creating tables, querying the database, inserting/updating rows.
    - lives in models.
    - this is only for the database you dont care about what yoou send to the front end helper
    - each instance of user is like one row in your databse.

schemas is to define how data should lok coming in from requests or going out in response
    - used for validation, serialization, and esnuring only safe feilds are returned.
    - UserCreate is used when creating a new user (from a post request)
    - UserRead is used when sending user data to the client (get request)
    - orm_mode = true allows you to take a SQLAlchemy object(user) and convert it into a pydnatic object (UserRead.from_orm(db_user))
    - you can exclude sensitive data like hashed_password when returning data to the client

    | Concept        | SQLAlchemy Model (models/)    | Pydantic Schema (schemas/)      |
| -------------- | ----------------------------- | ------------------------------- |
| Purpose        | Store data in DB              | Validate & shape API data       |
| Example        | `User` table                  | `UserCreate`, `UserRead`        |
| Sensitive info | All DB fields, incl password  | Only what’s safe to expose      |
| Where used     | Database queries, ORM objects | API request/response validation |

model is like storage blueprint inside db you use it when querying the database
scheme is used when calling the API 
    -data contract between the api and clients 
    -when validating input
    -when structuring Responsses
    -when making sure feilds are valid 
    -language contract

client -> scheme request json gets validated agaisnt a scheme
scheme -> model: you take the data and use it to create/update a db record
model -> Schema when you fetch rows from a db you wrap them in a response schemas
schema -> client fast api serializes the schema to json and sends it to the clientGreat. Lock the auth down and finish the basics in this order.

Set proper API results. Return 201 on signup and 200 on login. Return a consistent JSON shape for success and errors.

Add email verification. Generate a signed token. Send a link. Block login until verified or allow but warn, based on your rules.

Add rate limits and lockouts. Track failed logins. Lock after 5 bad tries for 15 minutes. Log the events.

Build password reset. Issue a one-time token with short expiry. Let users set a new password.

Issue short-lived access tokens and longer refresh tokens. Store tokens in httpOnly Secure SameSite cookies. Expose a refresh route. Add a logout route that clears cookies.

Protect routes. Add a FastAPI dependency that verifies JWT and pulls the user. Add role checks for admin endpoints. //we are here ======

Tighten CORS. Allow only your frontend origin. Allow credentials. Block wildcards.

Harden headers. Add SecurityMiddleware. Set HSTS in prod. Turn off docs in prod or protect with auth.

Finish the frontend. Set axios baseURL and withCredentials. Add an interceptor to attach Authorization only if you use header tokens. Show clear error messages for 400, 401, 409, and 422.

Polish the forms. Use type="text" and autocomplete="username" for usernames. Use type="password" and autocomplete="current-password". Validate before submit.

Migrate the DB. Create a User table with id, email, username, password_hash, is_active, is_verified, failed_attempts, last_login, role, created_at, updated_at. Use Alembic.

Test the flows. Write pytest tests for signup, login, refresh, logout, verify email, reset password, and protected routes. Add a Postman or Thunder Client collection.

Add observability. Log auth failures and 5xx. Add health checks. Track rate of 401s and lockouts.

Plan deploy. Use HTTPS only. Set strong SECRET_KEYs in env vars. Rotate keys on a schedule. Backup the DB.

Tell me which parts you want code for. I will drop the exact FastAPI routes, dependencies, and axios setup


ADMIN LOGIN TO TEST
username admin1224
email admin1224@hotmail.com
password Admin@1224